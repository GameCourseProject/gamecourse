#!/usr/bin/env python
# -*- coding: utf-8 -*-

from .. import validate

class TargetData:
	""" Data structure to hold information on the outputs generated by a
	RuleSystem, the rules that generated the outputs and the targets of those
	rules
	"""
	def __init__(self, tro=None):
		self._to = dict() # target --> list of outputs
		self._tr = dict() # target --> set of rules
		self._tro = dict() # (target,rule_key) --> output
		self._rules = dict() # rule_key --> rule
		if tro is None:
			return
		if not isinstance(tro,dict):
			Exception("not dict")
		for target in list(tro.keys()):
			if not isinstance(tro[target],dict):
				msg = "expected instance of 'dict', received "
				msg+= type(tro[target]).__name__
				raise TypeError(msg)
			for rule in list(tro[target].keys()):
				output = tro[target][rule]
				self.add(target,rule,output)

	def __repr__(self):
		msg = "<TargetData>"
		msg+= "\n\t<targets: %s>" % self.targets()
		msg+= "\n\t<outputs: %s>" % self.outputs()
		msg+= "\n\t<targets_outputs: %s>" % self._to
		tr = {}
		for t in self._tr:
			if isinstance(self._tr[t],set):
				i = 0
				for r in self._tr[t]:
					l = tr.get(t,[])
					l.append(self.rule_key(r))
					tr[t] = l
		msg+= "\n\t<target_rules: %s>" % tr
		msg+= "\n\t<target_ruleoutput: %s>" % self._tro
		msg+= "\n\t<rules: %s>" % list(self._rules.keys())
		return msg

	def add(self,target,rule,output):
		validate.rule(rule)
		validate.output(output)
		rule = self.rule_key(rule)
		if (target, rule) not in list(self._tro.keys()):
			# NEW ADDITION
			# Add the output to the target_outputs
			target_outputs = self._to.get(target,[])
			target_outputs.append(output)
			self._to[target] = target_outputs
			# add the rule to the target_rules
			target_rules = self._tr.get(target,[])
			target_rules.append(rule)
			self._tr[target] = target_rules
			# map the target-rulekey to the output
			self._tro[(target,rule)] = output
			# map the rulekey to the rule
			self._rules[rule] = rule
		elif self.target_ruleoutput(target,rule) != output:
			# remove previous output and add the new one to  the target_outputs
			prev = self.target_ruleoutput(target,rule)
			l = self._to[target]
			l.remove(prev)
			l.append(output)
			self._to[target] = l
			# replace the output of the target rule
			self._tro[(target,rule)] = output

	def get_target_data (self):
		""" returns a converted version of TARGETS_RULESOUTPUT, consisting of a
		dictionary where each key is a TARGET pointing to another dictionary
		where each key is the RULES the target activated and they point to an
		output produced by that rule
		"""
		td = {}
		for target in self.targets():
			td[target] = {}
			for rule in self.target_rules(target):

				output = self.target_ruleoutput(target,rule)
				output = output.convert()

				# this if condition will supress outputs for cases where the rule was fired
				# (in the case of having and integrated version of gamerules all rules are
				# fired because their effects may need to be reverted on the database)
				# but the output was empty
				#td[target] = {}
				td[target][rule] = output
				"""

				if output != [None]:
					# this if condition will supress outputs for cases where the rule was fired
					# (in the case of having and integrated version of gamerules all rules are
					# fired because their effects may need to be reverted on the database)
					# but the output was empty
					td[target] = {}
					td[target][rule] = output"""
		return td

	def outputs(self):
		result = []
		for elements in list(self._to.values()):
			result += elements
		return result

	def rm_rule(self,rule):
		""" removes the rule from the TargetData. Each one of its outputs and
		every target association with the rule is also removed.
		"""
		validate.rule(rule)
		rule = self.rule_key(rule)
		if rule not in list(self._rules.keys()):
			msg = "cannot remove a rule that doesn't exist"
			raise ValueError(msg)
		# delete all target outputs produced by the rule
		for target in self.rule_targets(rule):
			output = self.target_ruleoutput(target,rule)
			# remove the rule output from the TARGET_OUTPUTS
			self._to[target].remove(output)
			# remove the rule from the TARGET_RULES
			self._tr[target].remove(rule)
			# remove the rulekey and target association from TARGET_RULEOUTPUTS
			self._tro.pop((target,rule))
		# if the rule is no longer associated with any targets, remove the rule
		# from the TargetData known rules
		self._rules.pop(rule)

	def rm_target(self,target):
		""" removes the target from the TargetData. Each one of its outputs and
		every rule association with the target is also removed.
		"""
		if target not in self._tr:
			msg = "cannot remove a target that doesn't exist"
			raise ValueError(msg)
		# Remove (target, rule) from TARGET_RULEOUTPUTS
		for rule in self.target_rules(target):
			self._tro.pop((target,self.rule_key(rule)))
		# Remove target from TARGET_OUTPUTS
		self._to.pop(target)
		# Remove target from TARGET_RULES
		self._tr.pop(target)

	def rm_target_output(self,target,rule):
		""" removes the output of the rule for the given target """
		validate.rule(rule)
		rule = self.rule_key(rule)
		if (target,rule) not in self._tro:
			msg = "cannot remove an output from a target or rule that don't exist"
			raise ValueError(msg)
		# remove output from target_outputs
		output = self.target_ruleoutput(target,rule)
		self._to[target].remove(output)
		# remove rule from target_rules
		self._tr[target].remove(rule)
		# remove the ruleoutput from the target
		self._tro.pop((target,rule))

	def rules(self):
		return list(self._rules.values())

	def rule_exists(self,rule):
		rule = self.rule_key(rule)
		return rule in self._rules

	def rule_key(self,rule):
		from ..rules import Rule
		if isinstance(rule,Rule):
			return rule.name()
		return rule

	def rule_targets(self,rule):
		rule = self.rule_key(rule)
		return [k[0] for k in list(self._tro.keys()) if k[1] == rule]

	def targets(self):
		return [t for t in list(self._to.keys()) if len(self.target_outputs(t)) > 0]

	def target_exists(self,target):
		return target in self.targets()

	def target_hasrule(self,target,rule):
		rule = self.rule_key(rule)
		return rule in self._tr[target]

	def target_outputs(self,target):
		return self._to[target]

	def target_rules(self,target):
		return self._tr[target]

	def target_ruleoutput(self,target,rule):
		rule = self.rule_key(rule)
		return self._tro[(target,rule)]
