<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1">
    <title>GameCourse Documentation</title>
    <link rel="stylesheet" href="/gamecourse/css/navbar.css"/>
    <link rel="stylesheet" href="/gamecourse/css/docs.css"/>
    <link rel="stylesheet" href="/gamecourse/css/geral.css"/>
    <script src="/gamecourse/js/angular.min.js"></script>
    <script src="/gamecourse/js/jquery.min.js"></script>
    <script type="text/javascript" src="/gamecourse/docs/documentation.js"></script>
    <script type="text/javascript" src="documentation-modules.js"></script>
</head>
<body>
    <div class="navbar">  
        <div class="logo"></div>
        <ul class="menu documentation">
            <li id="menu-views"><a href="/gamecourse/docs" >Views</a></li>
            <li id="menu-functions"><a href="/gamecourse/docs/functions">Functions</a></li>
            <li id="menu-modules"><a href="javascript:void(0);" class="focused">Modules</a></li>
        </ul>
    </div>

    <div class="page">
        <div class="sidebar">
            <div class="tab search" id="find-tab">
                <input type="text" placeholder="Search.." name="search">
                <button class="magnifying-glass" id="search-btn"></button> 
            </div>
            <div class="tabgroup">
                <div class="tab selected" id="tab-create" >Module Creation</div>
                <div class="tab" id="tab-init" >Module Initialization</div>
                <div class="tab" id="tab-config" >Module Configuration</div>
                <div class="tab" id="tab-resources">Resources & Interaction</div>
                <div class="tab" id="tab-data">Accessible Data</div>
            </div>
        </div>
        
        <div class="content">
            <div class="section visible" id="create">
                <h2>Module Creation</h2>
                <div class="subsection">
                    <p>Creating a module is necessary if you want to use advanced features on the GameCourse, like defining functions or directives for Views, or to extend functionality of the GameCourse in a modular way.</p>
                    <h3>Creating an empty module</h3>
                    <p><span>All you need to get started is the following code in a file with the name </span><code>module.EmptyModule.php</code><span> inside a new directory in the directory of the modules. This directory has to use a lowercase name (the id given to the module), or it might not work in some systems.</span></p>
                    <pre class="code">
use GameCourse\Module;
use GameCourse\ModuleLoader;

class EmptyModule extends Module {
}

ModuleLoader::registerModule(array(
    'id' => 'empty',
    'name' => 'My Empty Module',
    'version' => '0.1',
    'factory' => function() {
        return new EmptyModule();
    }
));</pre>
                    <p>This code, creates an empty PHP class that is the module and registers it with the module loader, which will load it whenever it is required.</p>
                </div>
            </div>
            <div class="section" id="init">
                <h2>Module Initialization</h2>
                <div class="subsection">   
                    <p><span>To initialize something when the module initializes the function </span><code>init()</code><span> is used. It allows the module to use other features of the GameCourse core, like Navigation, or setup additional things required for the module.</span></p>
                    <p><span>As an example, lets define a new navigation button, which is only available for Administrators of the system. To do this, we start by defining our empty </span><code>init()</code><span> function inside the class.</span></p>
                    <pre class="code">
class EmptyModule extends Module {
<span class="highlight">    public function init() {
    }</span>
}</pre>
                    <p><span>Then we state that we need to use something that is part of the Core of the GameCourse system by appending </span><code>use GameCourse\Core</code><span> near the other use statements. An to conclude it we add the code that checks if the user is an Administrator and in that case add the navigation, resulting in the final code:</span></p>
                    <pre class="code">
<span class="highlight">use GameCourse\Core;</span>
use GameCourse\Module;
use GameCourse\ModuleLoader;

class <span class="highlight">CustomNavigation</span> extends Module {
    public function init() {
<span class="highlight">        $user = Core::getLoggedUser();
        if (($user != null && $user->isAdmin()))
            Core::addNavigation( 'TÃ©cnico', 'http://tecnico.ulisboa.pt');</span>
    }
}

ModuleLoader::registerModule(array(
    'id' => '<span class="highlight">customnav</span>',
    'name' => '<span class="highlight">Custom Navigation</span>',
    'version' => '0.1',
    'factory' => function() {
        return new <span class="highlight">CustomNavigation</span>();
    }
));</pre>
                    <p><span>The example can be downloaded </span><a href="pages/examples/customnavigation.tar.gz" aria-label="Custom Navigation Module Example">here</a><span>, ready to use, just needs to be extracted to the modules folder.</span></p>
                </div>
            </div>
            <div class="section" id="config">
                <h2>Module Configuration</h2>
                <div class="subsection">   
                    <p>You can setup a configuration page for your module to receive information form admin users. You can have a section for general type of inputs, a more personalized section and a place for listing items of the module and manage them (add, edit, delete).</p>
                    <h3>Declare your configuration page</h3>
                    <p>Fisrt thing you need to do is to declare that your module will have a configuration page, that is as simples as including this fuction on your php file:</p>
                    <pre class="code">
public function is_configurable(){
    return true;
}
</pre>
                    <p>Then you'll need to inform the system that there is a new url being used for that configuration page. If you don't already have one, create a new .js file inside a folder calles js on your directory. There include the following declaration: (Remember to always use your module id as reference)</p>
                    <pre class="code">
app.stateProvider.state('course.settings.empty', {
    url: '/empty',
    views : {
        'tabContent': {
            controller: 'ConfigurationController'
        }
    },
    params: {
        'module': 'empty'
    }
});</pre>
                    <h3>General Inputs Section</h3>
                    <p><span>On this section you can define which inputs you want on the configuration page. For that we use three functions on the Module file: 
                    </span><code>has_general_inputs()</code><span> which is alredy set to return false if you don' need this section, 
                    </span><code>get_general_inputs ($courseId)</code><span> so you can inform the controller (front-end) of which inputs you need and 
                    </span><code>save_general_inputs($generalInputs,$courseId)</code><span> so you can receive the information back when the user saves.</span></p>
                    <p><span>To use this section first declare public </span><code>function has_general_inputs (){ return true; }</code>
                    <span>Then specify which inputs you want through get fucntion. You'll need to define the 'name' you want to show for the input, it's 'id' for internal use and reference, a 'type' which can be any of the following: text, date, on_off button, select, color, number or paragraph. 'options' if you choose the select type and 'current_val' to show already defined information. Below there is an example of the possible types of inputs.</span></p>
                    <pre class="code">
public function get_general_inputs ($courseId){
    $input1 = array(<span class="highlight">'name'</span> => "input 1", 'id'=> 'input1', 'type' => "text", 'options' => "", 'current_val' => "things");
    $input2 = array('name' => "input 2", <span class="highlight">'id'</span> => 'input2', 'type' => "date", 'options' => "", 'current_val' => "");
    $input3 = array('name' => "input 3", 'id' => 'input3', <span class="highlight">'type'</span> => "on_off button", 'options' => '', 'current_val' => true);
    $input4 = array('name' => "input 4", 'id' => 'input4', 'type' => "select", <span class="highlight">'options'</span> => ["OpA","OpB","OpC"], 'current_val' => "");
    $input5 = array('name' => "input 5", 'id' => 'input5', 'type' => "color", 'options' => "", <span class="highlight">'current_val'</span> => "#121212");
    $input7 = array('name' => "input 7", 'id' => 'input7', 'type' => "number", 'options' => "", 'current_val' => "");
    $input8 = array('name' => "input 8", 'id' => 'input8', 'type' => "paragraph", 'options' => "", 'current_val' => "my text here");
    return [$input1, $input2, $input3, $input4, $input5, $input7, $input8];
} </pre>
                    <img src="./pagina_config_input_types.PNG">

                    <p><span>This section has a save button associated, when the user clicks on it, a save function will be called. There you'll receive the course id and general inputs information with the pairs id -> input so you can save the information as you need.</span></p>
                    <pre class="code">
public function save_general_inputs($generalInputs,$courseId){
    $input = $generalInputs["input_id"];
    $this->saveInput($input, $courseId);
}</pre>
                    <h3>Listing Items Section</h3>
                    <p><span>On this section you can list, add, edit and delete your module's items. For that to happen we use 3 functions: 
                    </span><code>has_listing_items ()</code><span> that by defualt is set to false, 
                    </span><code>get_listing_items ($courseId)</code><span> so you can define the table and items structure, and 
                    </span><code>save_listing_item ($actiontype, $listingItem, $courseId)</code><span> so you can save the information gather from the actions new, edit and delete. Don't worry we show a confirmation message before submitting any delete action.</span></p>

                    <p><span>To use this section first declare </span><code>public function has_listing_items(){ return true; }</code>
                    <span>Then you must gather your table and items information: choose wich item's attributes you want to show on the table ( in case they are a lot, choose a set of them) save the id of thoose atributes and the name you want to give to that collumn on seperate arrays but in the same order (displayAtributes and header correspondently). On another array place all your items information, including each item id. Then similar to the general inputs create an array with the information of each atribute and its type so we are able to create an add modal so the user can create a new item or edit an existing one. In this section the types available are: text, select, number, date and on_off button. To finish you'll need to define what it's name of your item and the items list. Return all of the above information on our get function.
                    </span></p>
                    <pre class="code">
public function get_listing_items ($courseId){
    $header = ['Name', 'Description', 'XP', 'Is Point'] ;
    $displayAtributes = ['name', 'description', 'xp', 'isPoint'];
    $items = getItems();
    $allAtributes = [
        array('name' => "Name", 'id'=> 'name', 'type' => "text", 'options' => ""),
        array('name' => "Description", 'id'=> 'description', 'type' => "text", 'options' => ""), 
        array('name' => "XP", 'id'=> 'xp', 'type' => "number", 'options' => ""),
        array('name' => "Levels", 'id'=> 'levels', 'type' => "number", 'options' => ""),
        array('name' => "Is Point", 'id'=> 'isPoint', 'type' => "on_off button", 'options' => "")
    ];
    return array( <span class="highlight">'listName'</span> => 'Badges', <span class="highlight">'itemName'</span> => 'Badge',<span class="highlight">'header'</span> => $header, <span class="highlight">'displayAtributes'</span> => $displayAtributes, <span class="highlight">'items'</span> => $items, <span class="highlight">'allAtributes'</span> => $allAtributes);
}</pre>

                    <p><span>In each action, add, edit or delete, the configuration API will be called and information will be delivered at the save function. There you'll have to analyse the 3 possible actions: On the add case you'll receive the pairs 
                    </span><code>atribute_id => value</code><span> for each of the attribute you specified above, on the var 
                    </span><code>$listingItem</code><span>. In case of edit you'll receive the same informtion as in the add case plus the id of the item selected to edit. On the delete case on the 
                    </span><code>$listingItem</code><span> you'll receive only the pair with the id value of the item to be deleted. Be aware that on_off fields with boolean values, while the value true comes as 1, false comes empty instead of 0.</span></p>

                    <pre class="code">
public function save_listing_item ($actiontype, $listingItem, $courseId){
    if($actiontype == 'new'){
        newItem($listingItem);
    }
    elseif ($actiontype == 'edit'){
        editItem($listingItem);

    }elseif($actiontype == 'delete'){
        deleteItem($listingItem['id']);
    }
}</pre>
                    <h3>Personalized Section</h3>
                    <p><span>If you need something more complex you can create your own section, build the front-end part and the API and resources needed. You'll just have to declare
                    </span><code>public function has_personalized_config (){ return true;}</code><span> and tell which function the controller needs to call in order to build that part of the page. </span></p>
                    <pre class="code">
public function get_personalized_function(){
    return "personalizedConfig";
}</pre>
                    <p><span>The controller will call that function and send as arguments the 
                    </span><code>$scope</code><span>, </span><code>$element</code><span>where you can attach your html structure, 
                    </span><code>$smartboards</code><span> in case you need it and the </span><code>$compile</code><span> so you can relate $scope information to html structure.
                    </span></p>
                    <pre class="code">
function personalizedConfig($scope, $element, $smartboards, $compile){
    ..
}</pre>
                </div>
            </div>
            <div class="section" id="resources">
                <h3>Setup Resources</h3>
                <p><span>If you want to define a module that applies CSS or needs Javascript, you need to specify which resources you want to include. This is done using the function </span><code>setupResources()</code><span> and using the function </span><code>addResources()</code><span> from the Module class to add the resources, which can be entire folders.</span></p>
                <pre class="code">
public function setupResources() {
    parent::addResources('css/'); // some styles
    parent::addResources('js/main.js'); // add main.js first
    parent::addResources('js/'); // other files depend on the main
}</pre>
                <h3>Other classes from the Module</h3>
                <p></span>To use other classes in the module, you can include them manually, or use the class loader provided by the GameCourse system. This class loader will load the file if the namespace starts with the name </span><code>Modules</code><span> followed by the directory of the plugin, for example, </span><code>namespace Modules/Views;</code>.</p>
                <p>The classes can then be created normally and are auto loaded by the system automatically, but considerations on the dependencies of the modules should be taken into account, due to the load order of the classes.</p>
                <h3>Interacting with other modules</h3>
                <p><span>To interact with other modules we simply request the module we want by using the function </span><code>getModule($module)</code><span> from the course. The requested module should be using the class loader way of loading classes, as explained in </span><a href="#OtherClassesFromModule">Other classes from the Module</a><span> and provide some kind of API for other modules to interact with it.</span></p>
                <p><span>As an example we can request the module </span><code>views</code><span> and get the view handler.</span></p>
                <pre class="code">
public function init() {
    $viewHandler = $this->getParent()->getModule('views')->getViewHandler();
}</pre>
            </div>
            <div class="section" id="data">
                <h3>Defining accessible data in the Data Schema</h3>
                <p><span>To define some type in the Data Schema some functions of the class </span><code>\GameCourse\DataSchema</code><span> are used. There are 4 different data types that can be registered. The types and functions used to create the objects to register in the data schema are in the following list:</span></p>
                <ul>
                    <li><span>Value/Field - </span><code>DataSchema::makeField</code></li>
                    <li><span>Array - </span><code>DataSchema::makeArray</code></li>
                    <li><span>Object - </span><code>DataSchema::makeObject</code></li>
                    <li><span>Map - </span><code>DataSchema::makeMap</code></li>
                </ul>
                <p><span>The functions </span><code>DataSchema::courseModuleDataFields</code><span> and </span><code>DataSchema::courseUserDataFields</code><span> exist to help create fields for the module and user.</span></p>
                <p><span>After obtaining the objects it is required to register those objects in the schema, using the function </span><code>DataSchema::register</code>.</p>
                <pre class="code">
public function init() {
    DataSchema::register(array(
        DataSchema::courseModuleDataFields($this, array(
            DataSchema::makeArray('levels', null,
                DataSchema::makeObject('level', null, array(
                    DataSchema::makeField('minxp', 'Min XP', 2000),
                    DataSchema::makeField('title', 'Title of the Level', 'Self-Aware')
                ))
            )
        ))
    ));
}</pre>
                <h3>Accessing Module Data</h3>
                <p><span>To access the module data, all that is needed to do is invoke the </span><code>getData</code><span> function from module class.</span></p>
                <pre class="code">$this->getData()->set('test', true');</pre>
                <h3>Accessing User Data</h3>
                <div class="subsection">
                    <p><span>To access user data it is necessary to get the user and then invoke the </span><code>CourseUser::getData</code><span> function to access the data.</span></p>
                    <pre class="code">$this->getParent()->getUser(12345)->getData()->set('test', true');</pre>
                    <p>In the example we get the user from the parent of the module, which is the course. Then we get the data from the user, which is wrapped by a DataWrapper, that manages the save automatically.</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

